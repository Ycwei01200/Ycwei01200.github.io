# Number of 1 Bits
[LeetCode](https://leetcode.com/problems/number-of-1-bits/)

## Problem Description

Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).

## Example & Constraints

Example 1:
```
Input: n = 11

Output: 3
```
Explanation:

The input binary string 1011 has a total of three set bits.

Example 2:
```
Input: n = 128

Output: 1
```
Explanation:

The input binary string 10000000 has a total of one set bit.

Example 3:
```
Input: n = 2147483645

Output: 30
```
Explanation:

The input binary string 1111111111111111111111111111101 has a total of thirty set bits.

**Constraints**

*  0 <= n <= $2^{31} - 1$

## Solution
```cpp
# bits calculation
class Solution {
public:
    int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            count += (n&1);
            n = n>>1;
        }
        return count;
    }
};
```

## Explanation
### Solution Analysis

這題其實就是簡單的位元運算，第一個方法比較著重於底層運算的處理方式

| 運算       | 意義                            |
| ---------- | ------------------------------- |
| `ans << 1` | 將 `ans` 左移一位，相當於乘以 2 |
| `n & 1`    | 取得 `n` 的最低位元             |
| `ans       | (n & 1)`                        | 將 `n` 的最低位元加入 `ans` 的最低位元 |
| `n >> 1`   | 將 `n` 右移一位，相當於除以 2   |

假設: <br>
n = 6 (binary: 0110)

| Operation      | Binary | Decimal |
| :------------- | :----- | :------ |
| `n >> 1`       | `0011` | `3`     |
| `n << 1`       | `1100` | `12`    |
| `n & 1`        | `0000` | `0`     |
| `(n >> 1) & 1` | `0001` | `1`     |

如果看得懂上面的表格，應該就看得懂程式碼了，就只要在計算的時候，看and運算後的結果去計算次數，就能得出結果


## Complexity
*   **Time Complexity:** $O(n)$
*   **Space Complexity:** $O(1)$