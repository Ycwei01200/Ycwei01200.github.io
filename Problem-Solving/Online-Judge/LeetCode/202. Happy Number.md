# Happy Number
[LeetCode](https://leetcode.com/problems/happy-number/)

## Problem Description

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

 
## Example & constraints
Example 1:
```
Input: n = 19
Output: true
```
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Example 2:
```
Input: n = 2
Output: false
```

Constraints:

1. 1 <= n <= $2^{31} - 1$
## Solution
```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> count;
        while(count.find(n) == count.end()){
            count.insert(n);
            n = next_num(n);
            if(n==1)return true;
        }
        return false;
    }
    
private:
    int next_num(int n){
        int m=0;
        if(n==1)return 1;

        while(n!=0){
            m += pow(n%10,2);
            n/=10;
        }
        return m;
    }


};
```
## Explanation
*   **Solution**
    *   這題我原本沒想這麼多，直接用遞迴去解，但會用重複計算的問題，如果是完全平方數就會導致無窮迴圈，並且實際會有一些bug(像是平方數的檢測，因為沒辦法回傳boolean，所以還要多算一個環節，這樣會比做一個陣列還要浪費時間)，所以我改成用 `unordered_set` 來存已經計算過的數字，如果再遇到就代表會有無窮迴圈，就直接返回 false。
    *   至於`next_num`是用來計算下一個數字的

## Complexity
*   **Time Complexity:** $O(log n)$
*   **Space Complexity:** $O(log n)$ 