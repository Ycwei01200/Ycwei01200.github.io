# Word Pattern
[LeetCode](https://leetcode.com/problems/word-pattern/)

## Problem Description

Given a pattern and a string s, find if s follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:

*   Each letter in pattern maps to exactly one unique word in s.
*   Each unique word in s maps to exactly one letter in pattern.
*   No two letters map to the same word, and no two words map to the same letter.

## Example

Example 1:
```
Input: pattern = "abba", s = "dog cat cat dog"

Output: true
```
Explanation:

The bijection can be established as:

'a' maps to "dog".
'b' maps to "cat".
Example 2:
```
Input: pattern = "abba", s = "dog cat cat fish"

Output: false
```
Example 3:
```
Input: pattern = "aaaa", s = "dog cat cat dog"

Output: false
```
Constraints:

*   1 <= pattern.length <= 300
*   pattern contains only lower-case English letters.
*   1 <= s.length <= 3000
*   s contains only lowercase English letters and spaces ' '.
*   s does not contain any leading or trailing spaces.
*   All the words in s are separated by a single space.
## Solution
```cpp
#include <sstream>
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        istringstream ss(s);
        string word;
        vector<string> mapping;
        while(ss>>word){mapping.push_back(word);}

        if(mapping.size() != pattern.size()) return false;

        unordered_map<char,string> map1;
        unordered_map<string,char> map2;

        for(int i=0;i<pattern.size();i++){
            char key = pattern[i];
            string val   = mapping[i];

            if(map1.count(key) && map1[key] != val)return false;
            if(map2.count(val) && map2[val] != key)return false;

            map1[key] = val;
            map2[val] = key;

        }
        return true;
    }
};
```
## Explanation

這題的要求是說，給你兩個字串，一個是 `pattern`，一個是 `s`，那pattern的每一個字元有獨一無二的對應字串，那必須遵守

*   每一個字元對應的字串不能重複
*   每一個字串不能對應多個字元
*   字串對應的字元不能重複，反之則反

### 解題思路

* 雙重hash map，確保兩邊的字元和字串都一一對應並且沒有重複
* 空格處用`stringstream`來處理，避免有多個字元對應到同一個字串的情況發生
* 每次加入新的字元/字串，都要檢查是否已經對應過


## Time Complexity

* $O(n)$