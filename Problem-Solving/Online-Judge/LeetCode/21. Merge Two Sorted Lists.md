# Merge Two Sorted Lists
[LeetCode](https://leetcode.com/problems/merge-two-sorted-lists/)

## Problem Description

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

## Example

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

```
Input: list1 = [], list2 = []
Output: []
```
```
Input: list1 = [], list2 = [0]
Output: [0]
```

## Solution
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode*  list3 = new ListNode();
        bool first = true;
        ListNode* temp1 = list1;
        ListNode* temp2 = list2;
        ListNode* temp3 = list3;

        
        if(temp1 == NULL) return list2;
        else if(temp2 == NULL)          return list1;

        while(temp1!= NULL && temp2!= NULL){
            
            if(temp1->val == temp2->val){
                if(first){
                    first=false; 
                    temp3->val = temp1->val;
                    temp3->next = new ListNode();
                    temp3->next->val = temp2->val;
                    temp3 = temp3 ->next;

                    temp1 = temp1->next;
                    temp2 = temp2->next;;
                    
                }
                else{
                    temp3->next = new ListNode();
                    temp3->next->val = temp2->val;
                    temp3 = temp3 ->next;
                    temp3->next = new ListNode();
                    temp3->next->val = temp1->val;
                    temp3 = temp3 ->next;
                    temp2 = temp2->next;
                    temp1 = temp1->next;
                }


            }
            else if(temp1->val > temp2->val){
                if(first){
                    first=false; 
                    temp3->val = temp2->val; temp2=temp2->next;
                    
                }
                else{
                    temp3->next = new ListNode();
                    temp3->next->val = temp2->val;
                    temp3 = temp3 ->next;
                    temp2 = temp2->next;
                }
            }
            else if(temp1->val < temp2->val){
                if(first){
                    first=false; 
                    temp3->val = temp1->val; temp1=temp1->next;
                    
                }
                else{
                    temp3->next = new ListNode();
                    temp3->next->val = temp1->val;
                    temp3 = temp3 ->next;
                    temp1 = temp1->next;
                }
            }
            
        }
        if(temp2!=NULL){
            temp3->next = temp2;
        }
        else if(temp1!=NULL){
            temp3->next = temp1;
        }

        return list3;
    }
};
```

## Explanation

This solution merges two sorted linked lists by comparing nodes one by one:

1. **Edge Cases**: First, handle empty lists - if either list is empty, return the other list directly (lines 50-51)

2. **Initialize Pointers**: Create a new list (`list3`) and three pointers:
   - `temp1`: traverses `list1`
   - `temp2`: traverses `list2`  
   - `temp3`: builds the merged list

3. **Merge Process**: While both lists have remaining nodes (line 53):
   - Compare values at `temp1` and `temp2`
   - Add the smaller value to the merged list
   - Move the corresponding pointer forward
   - Use a `first` flag to handle the initial node differently

4. **Handle Remaining Nodes**: After the loop, one list may still have nodes remaining:
   - If `temp2` has remaining nodes, attach them to `temp3->next` (lines 108-110)
   - If `temp1` has remaining nodes, attach them to `temp3->next` (lines 111-113)
   - Since both input lists are already sorted, we can directly attach the remaining portion

5. **Return**: Return `list3`, which now contains the merged sorted list
*  the most important thing is to check whether the first node is zero or not,if it is zero,then we need to overwrite the first node;else we need to create a new node and move to the next node then overwritting it.
*  the last thing is to check whether the list1 or list2 is empty,if it is empty,then we need to connect the new list to the remaining list.

## Time Complexity
*  $O(N+M)$ 