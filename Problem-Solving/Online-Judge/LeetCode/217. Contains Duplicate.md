# Contains Duplicate
[LeetCode](https://leetcode.com/problems/contains-duplicate/)

## Problem Description

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

## Example & Constraints

Example 1:
```
Input: nums = [1,2,3,1]

Output: true
```
Explanation:

The element 1 occurs at the indices 0 and 3.

Example 2:
```
Input: nums = [1,2,3,4]

Output: false
```
Explanation:

All elements are distinct.

Example 3:
```
Input: nums = [1,1,1,3,3,4,3,2,4,2]

Output: true
```
**Constraints**

*   1 <= nums.length <= $10^5$
*   $-10^9 <= nums[i] <= 10^9$

## Solution
```cpp
//sort and unique version
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size();
        int new_size = unique(nums.begin(),nums.end())-nums.begin();
        if(n>new_size)return true;
        else          return false;
    }
};
```
```cpp
//unordered_set version
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_map<int,int> map;
        map.clear();
        for(int i=0;i<nums.size();i++){
            if(map.count(nums[i]))return true;
            else                 map[nums[i]]++;
        }
        return false;
    }
};
```

## Explanation
### Solution Analysis
* 這題，我比較偷懶，直接用sort和unique來做，畢竟去重這個函數有個特點，會把重複地往後丟，剩下的往前移動，所以大小會比原本的小，如果有重複的話，我就看有沒有重複，有就return true，沒有就return false
* 另外一個版本是用unordered_map來做，在塞進去map的時候順便檢查，如果已經有重複的值，就return true，否則return false，理論上時間複雜度比較低，但空間複雜度會高一些

## Complexity
### Sort and Unique Version
*   **Time Complexity:** $O(nlogn)$
*   **Space Complexity:** $O(1)$

### Unordered Map Version
*   **Time Complexity:** $O(n)$
*   **Space Complexity:** $O(n)$
