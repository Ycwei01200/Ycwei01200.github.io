# Third Maximum Number

[LeetCode](https://leetcode.com/problems/third-maximum-number/)

## Problem Description

Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
 
## Example & constraints
Example 1:
```
Input: nums = [3,2,1]
Output: 1
```
Explanation: <br>
The first distinct maximum is 3.<br>
The second distinct maximum is 2.<br>
The third distinct maximum is 1.
Example 2:
```
Input: nums = [1,2]
Output: 2
```
Explanation: <br>
The first distinct maximum is 2.<br>
The second distinct maximum is 1.<br>
The third distinct maximum does not exist, so the maximum (2) is returned instead.
Example 3:
```
Input: nums = [2,2,3,1]
Output: 1
```
Explanation: <br>
The first distinct maximum is 3.<br>
The second distinct maximum is 2 (both 2's are counted together since they have the same value).<br>
The third distinct maximum is 1.

## Solution
```cpp
// solution 1
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        nums.erase(unique(nums.begin(),nums.end()),nums.end());

        int n = nums.size();
        return n < 3 ? nums[n-1] : nums[n-3];
    }
};
```
```cpp
// solution 2
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        long long first =   LLONG_MIN;
        long long  second = LLONG_MIN;
        long long third =   LLONG_MIN;
        for(auto&c:nums){
            if(c == first || c == second || c == third)continue;

            if(c > first){
                third = second;
                second = first;
                first = c;
            }
            else if(c > second){
                third = second;
                second = c;
            }
            else if(c > third){
                third = c;
            }
        }
        if(third == LLONG_MIN)return first;
        else             return third;
    }
};
```

## Explanation
*  第一種寫法就是純內建語法，先排序再刪除重複的，最後回傳第三大的數，如果沒有就回傳最大的數。
*  第二種寫法就是用三個變數來記錄前三大數，然後依序比較，最後回傳第三大的數，如果沒有就回傳最大的數。
*  兩者的差別在於說，第一個時間複雜度較高，但是就是純內建語法，沒有甚麼特別的，第二種是題目要求的，時間複雜度控制在$O(n)$，排序+去重就$O(nlogn)$了，所以只能一邊巡歷一邊記錄。
  
## Time Complexity
### solution 1
*  $O(nlogn)$
### solution 2
*  $O(n)$
## Space Complexity
### solution 1
*  $O(1)$
### solution 2
*  $O(1)$





