# Reverse Bits
[LeetCode](https://leetcode.com/problems/reverse-bits/)

## Problem Description

Reverse bits of a given 32 bits signed integer.

## Example & Constraints

Example 1:
```
Input: n = 43261596

Output: 964176192
```
Explanation:

| Integer   | Binary                           |
| --------- | -------------------------------- |
| 43261596  | 00000010100101000001111010011100 |
| 964176192 | 00111001011110000010100101000000 |

Example 2:
```
Input: n = 2147483644

Output: 1073741822
```
Explanation:

| Integer    | Binary                           |
| ---------- | -------------------------------- |
| 2147483644 | 01111111111111111111111111111100 |
| 1073741822 | 00111111111111111111111111111110 |
 

**Constraints**

*  0 <= n <= $2^{31} - 2$
*  n is even.

## Solution
```cpp
# bits calculation
class Solution {
public:
    int reverseBits(int n) {
        int ans=0;
        for(int i=0;i<32;i++){
            ans = ans << 1;
            ans = ans | (n&1);
            n = n >> 1;
        }
        return ans;
    }
};
```

### other solution

```cpp
class Solution {
public:
    int reverseBits(int n) {
        string ans = calc(n);
        int ans1=0;
        for(int i=0;i<ans.size();i++){
            if(ans[i]=='1')ans1 += pow(2,i);
        }
        return ans1;
    }

private:
    string calc(int n){
        string s="";
        while(n!=0){
            s+=((n%2)+'0');
            n/=2;
        }
        while(s.size()<32){s.push_back(0);}
        reverse(s.begin(),s.end());
        
        return s;
    }
};
```
## Explanation


### Solution Analysis

這題其實就是簡單的位元運算，第一個方法比較著重於底層運算的處理方式

| 運算       | 意義                            |
| ---------- | ------------------------------- |
| `ans << 1` | 將 `ans` 左移一位，相當於乘以 2 |
| `n & 1`    | 取得 `n` 的最低位元             |
| `ans       | (n & 1)`                        | 將 `n` 的最低位元加入 `ans` 的最低位元 |
| `n >> 1`   | 將 `n` 右移一位，相當於除以 2   |

假設: <br>
n = 6 (binary: 0110)

| Operation      | Binary | Decimal |
| :------------- | :----- | :------ |
| `n >> 1`       | `0011` | `3`     |
| `n << 1`       | `1100` | `12`    |
| `n & 1`        | `0000` | `0`     |
| `(n >> 1) & 1` | `0001` | `1`     |

如果看得懂上面的表格，應該就看得懂程式碼了，迴圈32次去補位數，順便做十進位轉二進位(但其實電腦底層邏輯就是以二進位在跑，只是我們用十進位在看而已)，一次處理一位數，然後`ans<<1`把原本的`ans`往左移一位(等效於乘以2)，然後`n>>1`把原本的`n`往右移一位(等效於除以2)跟ans 去做或運算，n 再重複這個動作，直到n變為0。

### Other Solutions

*   如果實在是不理解，那就以字串的方式去做也可以，只是會比較慢，但至少看得懂，首先是，`calc(n)`會把n轉成二進位字串，就是一直取餘數，然後除以2，直到n變為0，然後補0到32位，再反轉，最後再轉成十進位，接著根據題目要求，把二進位字串反轉，再轉成十進位，但如果數字再大會爆掉，這時候就要用更多方法去處理`pow`，可能快速冪，但說實話，這時候還是學比較底層的運算會比較好寫。


## Complexity
### Solution 1
*   **Time Complexity:** $O(1)$
*   **Space Complexity:** $O(1)$ 

### Solution 2
*   **Time Complexity:** $O(n)$
*   **Space Complexity:** $O(n)$ 