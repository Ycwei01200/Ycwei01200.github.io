# Intersection of Two Arrays
[LeetCode](https://leetcode.com/problems/intersection-of-two-arrays/)

## Problem Description

Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

## Example

Example 1:
```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
```

Example 2:
```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
```
Constraints:

*   1 <= nums1.length, nums2.length <= $10^4$
*   0 <= nums1[i], nums2[i] <= $10^4$

## Solution
```cpp
//STL solution
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nums3;
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        set_intersection(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),inserter(nums3,nums3.begin()));
        auto temp = unique(nums3.begin(),nums3.end())-nums3.begin();
        nums3.resize(temp);
        return nums3;

    }
};
``` 
```cpp
//two pointer solution
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> nums3;
        nums3.clear();
        int left1 = 0,left2 = 0;
        while(left1 < nums1.size() && left2 < nums2.size()){
            if(nums1[left1] == nums2[left2]){
                if(nums3.empty()|| nums3.back() != nums1[left1]){
                    nums3.push_back(nums1[left1]);
                }
                
                left1++;left2++;
            }
            else if(nums1[left1] < nums2[left2]){
                left1++;
            }
            else{
                left2++;
            }
        }
        return nums3;
    }
};
```
```cpp
//hashmap solution
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set <int> nums3(nums1.begin(),nums1.end());
        unordered_set <int> ans;
        for(auto&x:nums2){
            if(nums3.count(x))ans.insert(x);
        }
        return vector<int>(ans.begin(),ans.end());
    }
};
```
## Explanation
*  STL solution
    *  第一個方法，比較不用想這麼多，直接用STL的set_intersection，但要注意用法，跟最後還是要去重。
*  Two pointer solution
    *  第二個方法，用兩個指標，兩個分別在nums1和nums2的最前面，然後去找相同的數字，如果找到相同的數字，那就要確認說，是否曾經加入過nums3(因為排序過，所以找最後一個肯定能確認，但避免overflow，所以確認nums3是否為空)，如果沒有加入過，那就要加入，如果加入過，那就指標移動，直到找到下一個相同的數字
*  HashMap solution
    *  第三個方法，用一個unordered_set來存nums1的數字，然後遍歷nums2，然後確認說，nums1有沒有跟num2有相同的數字，有相同的數字，就加入到ans中，最後return ans，然後有一點很酷的是，可以把`unordered_set`轉成`vector`使用，雖然整體的時間複雜度比前兩個方法要低，但是空間複雜度就有點高了
## Time Complexity
### STL solution
*  $O(nlogn)$
### Two pointer solution
*  $O(nlogn)$
### HashMap solution
*  $O(n+m)$