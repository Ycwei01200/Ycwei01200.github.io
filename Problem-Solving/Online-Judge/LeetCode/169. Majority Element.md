# Majority Element
[LeetCode](https://leetcode.com/problems/majority-element/)

## Problem Description

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
 
## Example & Constraints

**Example 1**

```
Input: nums = [3,2,3]
Output: 3
```

**Example 2**

```
Input: nums = [2,2,1,1,1,2,2]
Output: 2
```

**Constraints**

*   `n == nums.length`
*   `1 <= n <= 5 * 10^4`
*   `-10^9 <= nums[i] <= 10^9`
*   The input is generated such that a majority element will exist in the array.

## Solution

### Boyer-Moore Voting Algorithm

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = 0;
        int count = 0;
        for(auto& num : nums){
            if(count == 0){
                candidate = num;
            }

            if(num == candidate) count++;
            else                 count--;
        }
        return candidate;
    }
};
```

### Hash Map

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> countmap;
        int times = nums.size()/2;
        for(auto& c : nums) {
            countmap[c]++;
        }
        for(auto& it : countmap) {
            int num = it.first;
            int count = it.second;
            if(count > times) return num;
        }
        return -1;
    }
};
```
## Explanation

### Solution Analysis

這題是一個摩爾投票法的題目（Boyer-Moore Voting Algorithm），簡言之它有幾個規則：
*   你可以想像成有三個候選人：

```text
Input: nums = [3,2,3]
Output: 3

round 1: 
candidate = 3
count = 1

round 2:
candidate = 2
count = 0 

# 因為 2 不是候選人 (3)，所以 count - 1，類似於抵消的概念

round 3:
candidate = 3
count = 1

# 因為 2 的票數已經被抵銷掉了，所以目前 3 有一票，所以最後 3 是 candidate
```

*   最後剩下的人就是冠軍。它的特點是快，只要跑完所有元素就一定會剩下它，並且 Space Complexity 為 $O(1)$，因為只用了兩個變數去存。

### Other Solutions

*   正常的解法可以用 Hash Map 去解，Time Complexity 是 $O(n)$，Space Complexity 是 $O(n)$。雖然也不是不能解，但就是跟題目理想狀態上要求的複雜度有點落差，我也放在上方解答了。


## Complexity
*   **Time Complexity:** $O(n)$
*   **Space Complexity:** $O(1)$ 