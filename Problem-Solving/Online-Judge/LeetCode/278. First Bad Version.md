# First Bad Version
[LeetCode](https://leetcode.com/problems/first-bad-version/)

## Problem Description

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

## Example

Example 1:
```
Input: n = 5, bad = 4
Output: 4
```
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
Example 2:
```
Input: n = 1, bad = 1
Output: 1
```
Constraints:

*   1 <= n <= $2^{31} - 1$

## Solution
```cpp
// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int left=0,right=n;
        while(left<=right){
            int mid = left + (right-left)/2;
            if(isBadVersion(mid)){
                right = mid - 1;
            }
            else{
                left = mid + 1;
            }
        }
        return left;
    }
};
```
## Explanation

*   這題，主要是說，如果這一群流水線中，有一個版本是壞的，那所有的版本都是壞的，所以你要找到第一個壞的版本，那她已經寫好了判斷的函數`isBadVersion`，所以你要找第一個壞的，理論上是for-loop跑完，不然要怎麼找，但是這樣會超時，所以我們可以使用二分法
*   二分法的適用條件就是，你要找的東西是有序且遞增的，所以當我們在找的時候，如果這個產品判斷為壞掉的，右界就要縮小，如果沒有壞掉，左界就要縮小，以此類推找到目標。



## Time Complexity

### 0ms version
* $O(logn)$