# Move Zeroes
[LeetCode](https://leetcode.com/problems/move-zeroes/)

## Problem Description

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.


## Example

Example 1:
```
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
```
Example 2:
```
Input: nums = [0]
Output: [0]
```

Constraints:

*   1 <= nums.length <= $10^4$
*   $-2^{31} <= nums[i] <= 2^{31} - 1$
## Solution
```cpp
//0ms version
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]!=0){
                swap(nums[slow],nums[i]);
                slow ++;
            }
        }
    }
};
```
## Explanation

這題主要是說，你不能用複製陣列的方式，所以你要把所有的 `0` 移到後面，同時，剩下的非零數字要維持原本的順序。

我們可以使用 **快慢指針 (Two Pointers)** 的方式：
*   **快指針 (`i`)**：用來遍歷陣列。
*   **慢指針 (`slow`)**：用來記錄非零數字應該放置的位置 (也同時是目前 `0` 的位置)。

當 `i` 遇到非零數字時，就與 `slow` 指向的位置進行交換。

---

### 舉例說明:
假設陣列是 `[0, 1, 0, 3, 12]`：

1.  **開始**：`slow=0`, `i=0`。
    *   `nums[0]` 是 `0`，跳過。
2.  **i=1**：`nums[1]` 是 `1` (非零)。
    *   執行 `swap(nums[0], nums[1])`。
    *   陣列變為：`[1, 0, 0, 3, 12]`，`slow` 變成 `1`。
3.  **i=2**：`nums[2]` 是 `0`，跳過。
4.  **i=3**：`nums[3]` 是 `3` (非零)。
    *   執行 `swap(nums[1], nums[3])`。
    *   陣列變為：`[1, 3, 0, 0, 12]`，`slow` 變成 `2`。
5.  **i=4**：`nums[4]` 是 `12` (非零)。
    *   執行 `swap(nums[2], nums[4])`。
    *   陣列變為：`[1, 3, 12, 0, 0]`，`slow` 變成 `3`。

**結果**：非零元素 `1`, `3`, `12` 順序沒變，且 `0` 全都跑到了最後面！


## Time Complexity

### 0ms version
* $O(n)$