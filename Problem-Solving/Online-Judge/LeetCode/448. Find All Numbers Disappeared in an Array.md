# 448. Find All Numbers Disappeared in an Array

[LeetCode](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

## Problem Description

Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

 
## Example & constraints
Example 1:
```
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
```
Example 2:
```
Input: nums = [1,1]
Output: [2]
```
### Constraints:

*   n == nums.length
*   1 <= n <= $10^5$
*   1 <= nums[i] <= n
 

### Follow up:

Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

## Solution
### Method 1
```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        vector<int> count(n+1,0);
        vector<int> missnum;
        for(auto&c:nums){
            count[c]++;
        }
        for(int i=1;i<count.size();i++){
            if(count[i]==0)missnum.push_back(i);
        }
        return missnum;
    }
};
```
### Method 2
```cpp
//follow-up way
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            int val = abs(nums[i]);
            int index = val-1;
            if(nums[index] > 0)nums[index] = -nums[index];
        }
        for(int i=0;i<nums.size();i++){
            if(nums[i]>0)ans.push_back(i+1);
        }
        return ans;
    }
};
```

## Explanation
*  這題，有幾個方法，如果單純要過測資，而不解follow-up，你只要多用一個計數表，去存出現過的數字的次數，然後再跑一次迴圈，去確認沒出現過的次數就好
*  第二個方法，就是遵守follow-up，不運用除了回傳的陣列以外的空間，你可以將陣列裡面的數字代表的`index`，塗成負數，代表曾經出現過，如果數字是正數，那就代表沒出現過，舉個例子好了。

以 `nums = [4,3,2,7,8,2,3,1]` 為例，遍歷每個數字，取絕對值 `val`，把 `nums[val-1]` 塗成負數：

| Step | i   | val = \|nums[i]\| | 操作               | 陣列狀態                    |
| ---- | --- | ----------------- | ------------------ | --------------------------- |
| 1    | 0   | 4                 | nums[3] → 負       | [4,3,2,**-7**,8,2,3,1]      |
| 2    | 1   | 3                 | nums[2] → 負       | [4,3,**-2**,-7,8,2,3,1]     |
| 3    | 2   | 2                 | nums[1] → 負       | [4,**-3**,-2,-7,8,2,3,1]    |
| 4    | 3   | 7                 | nums[6] → 負       | [4,-3,-2,-7,8,2,**-3**,1]   |
| 5    | 4   | 8                 | nums[7] → 負       | [4,-3,-2,-7,8,2,-3,**-1**]  |
| 6    | 5   | 2                 | nums[1] 已負，跳過 | [4,-3,-2,-7,8,2,-3,-1]      |
| 7    | 6   | 3                 | nums[2] 已負，跳過 | [4,-3,-2,-7,8,2,-3,-1]      |
| 8    | 7   | 1                 | nums[0] → 負       | [**-4**,-3,-2,-7,8,2,-3,-1] |

最終陣列：`[-4,-3,-2,-7,8,2,-3,-1]`

再遍歷一次，若 `nums[i] > 0`，代表 `i+1` 從未出現：
* `nums[4] = 8 > 0` → **5** 消失
* `nums[5] = 2 > 0` → **6** 消失

輸出：`[5, 6]` ✓
  
## Time Complexity
### Method 1
*   $O(n)$
### Method 2
*   $O(n)$
## Space Complexity
### Method 1
*   $O(n)$
### Method 2
*   $O(1)$





