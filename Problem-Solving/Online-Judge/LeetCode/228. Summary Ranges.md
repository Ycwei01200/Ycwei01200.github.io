# Summary Ranges


[LeetCode](https://leetcode.com/problems/summary-ranges/)

## Problem Description

You are given a sorted unique integer array nums.

A range [a,b] is the set of all integers from a to b (inclusive).

Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.

Each range [a,b] in the list should be output as:

"a->b" if a != b
"a" if a == b

## Example & Constraints

Example 1:
```
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
```

Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"


Example 2:
```
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
```
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
 

**Constraints**:

* 0 <= nums.length <= 20
* -$2^{31}$ <= nums[i] <= $2^{31} - 1$
* All the values of nums are unique.
* nums is sorted in ascending order.

## Solution
```cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int left1=0;
        vector<string> output;

        output.clear();
        for(int i=0;i<nums.size();i++){
            if(i+1 == nums.size() || nums[i+1]!=(nums[i]+1))
            {
                if(left1==i){
                    output.push_back(to_string(nums[left1]));
                }
                else{
                    output.push_back(to_string(nums[left1])+"->"+to_string(nums[i]));
                }
                left1=i+1;
            }
            
        }
        return output;
        
            
    }
};
```
## Explanation
### Solution Analysis

* 這題我用雙指標解，因為他要找連續的數組，`left1`用來固定數組的第一個數字，`i`則是第二個數字，但要注意的是越界跟overflow的問題，所以要檢查是否在最後一個位置，無論是否連續都要印出並結束，大概是這樣的概念，最後的left1因為是新的範圍，所以要設定為`i+1`



## Complexity
*   **Time Complexity:** $O(n)$
*   **Space Complexity:** $O(n)$

