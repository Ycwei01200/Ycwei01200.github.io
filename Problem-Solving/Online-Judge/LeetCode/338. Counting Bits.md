# Counting Bits
[LeetCode](https://leetcode.com/problems/counting-bits/)

## Problem Description

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

## Example

Example 1:
```
Input: n = 2
Output: [0,1,1]
```
Explanation:  
0 --> 0  
1 --> 1  
2 --> 10  

Example 2:
```
Input: n = 5
Output: [0,1,1,2,1,2]
```
Explanation:  
0 --> 0  
1 --> 1  
2 --> 10  
3 --> 11  
4 --> 100  
5 --> 101  

Constraints:

1. 0 <= n <= $10^5$
 

## Solution
```cpp
//dp 
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> count_num(n+1,0);
        for(int i=1;i<=n;i++){
            count_num[i] = count_num[i>>1] + i % 2;
        }
        return count_num;
    }
};
```
```cpp
//calc bits
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> count(n+1);
        int countnum;
        for(int i=0;i<=n;i++){
            int l = i;
            countnum = 0;
            while(l!=0){
                if(l%2!=0)countnum++;
                l/=2;
            }
            count[i] = countnum ; 
        }
        return count;
    }
};
```

## Explanation
*  這題DP我也是剛學到，他有一個規律
*  如果是 odd ， `count_num[i] = count_num[i>>1] + i%2`
*  如果是 even ， `count_num[i] = count_num[i>>1]` <br>

舉個例子好了: 
```text
0 = 0
1 = 01 => 1 = count_num[1>>1] + 1 % 2 == 1
2 = 10 => 1 = count_num[2>>1] + 2 % 2 == 1
3 = 11 => 2 = count_num[3>>1] + 3 % 2 == 2
4 = 100 => 1 = count_num[4>>1] + 4 % 2 == 1
5 = 101 => 2 = count_num[5>>1] + 5 % 2 == 2
6 = 110 => 2 = count_num[6>>1] + 6 % 2 == 2
7 = 111 => 3 = count_num[7>>1] + 7 % 2 == 3
8 = 1000 => 1 = count_num[8>>1] + 8 % 2 == 1
```
* 是有這麼一個規律在的，如果每個都用硬算的，在效率上不太建議，但我還是附上


  
## Time Complexity
### DP
*  $O(n)$ 
### calc bits
*  $O(n log n)$